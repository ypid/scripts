#!/usr/bin/perl
use strict;
use warnings;
use utf8;
use open ':encoding(UTF-8)';
use open ':std';
use Encode qw(encode decode);
use IO::Handle;
use English '-no-match-vars';
use Fatal qw(open close read);
use Class::Struct;
use File::Find;
use Cwd qw(realpath);
use Getopt::Long;
use Digest::MD5 qw();
use Pod::Usage;

# Argument Parsing
my $delete = 0;
my $ask    = 0;
my $help   = 0;
my $man    = 0;

GetOptions(
    'delete' => \$delete,
    'ask'    => \$ask,
    'help'   => \$help,
    'man'    => \$man,
);

# Help Textes
pod2usage(
    {
        -verbose => 1,
    }
) if $help;
pod2usage(
    {
        -verbose => 2,
    }
) if $man;

# Simple Class for a File
struct File => {
    'name' => '$',
    'size' => '$',
};

# Package File
{
    package File;
    use English '-no-match-vars';
    use overload q{""} => sub { $_[0]->name };
    # Generate a MD5 hash for the first 64kb of a file.
    sub md5_64kb {
        my ($self) = @_;
        return $self->{cache_md5_64k} if exists $self->{cache_md5_64k};

        my $ret = eval {
            open my $file, '<:bytes', $self->name;
            read $file, my $f64kb, 65536;
            close $file;

            return $self->{cache_md5_64k} = Digest::MD5::md5_hex($f64kb);
        };
        return $ret if !$EVAL_ERROR;

        die "Cannot create MD5 sum of first 64kb of file $self: $!\n"
          if $EVAL_ERROR;
    }
    # Generate a MD5 hash for the complete file
    sub md5 {
        my ($self) = @_;
        if ( $self->size <= 65536 ) {
            return $self->{cache_md5} = $self->md5_64kb;
        }
        return $self->{cache_md5} if exists $self->{cache_md5};

        my $ret = eval {
            open my $file, '<:bytes', $self->name;
            my $md5_hex = Digest::MD5->new->addfile($file)->hexdigest;
            close $file;

            return $self->{cache_md5} = $md5_hex;
        };
        return $ret if !$EVAL_ERROR;

        die "Cannot create MD5 sum for the file $self: $!\n"
          if $EVAL_ERROR;
    }
}

# The Container for all files
my @files;

# Find all Files and insert them into Container as File Objects.
find(
    {
        no_chdir => 1,
        wanted   => sub {
            if ( -f $File::Find::name ) {
                push @files,
                  File->new(
                    name => decode( 'UTF-8', realpath($File::Find::name) ),
                    size => -s $File::Find::name
                  );
            }
        },
    },
    @ARGV ? @ARGV : '.'
);

# save how often a file_size is seen.
my %file_size;
for my $file (@files) {
    push @{ $file_size{ $file->size } }, $file;
}

# Save the amount of space that freed after delete
my $total_size = 0;

FILE_SIZE:
for my $files_aref ( values %file_size ) {
    my @files = @$files_aref;
    next FILE_SIZE if @files <= 1;

    # Generate a hash with 64kb files as key
    my %md5_64kb;
    for my $file (@files) {
        push @{ $md5_64kb{ $file->md5_64kb } }, $file;
    }

  MD5_64KB:
    for my $files_aref ( values %md5_64kb ) {
        my @files = @$files_aref;
        next MD5_64KB if @files <= 1;

        # Generate a hash with the complete md5s
        my %md5;
        for my $file (@files) {
            push @{ $md5{ $file->md5 } }, $file;
        }

        # Equal files
        for my $md5 ( keys %md5 ) {
            my @files = @{ $md5{$md5} };

            # Delete
            if ($delete) {
                my $not_deleted = shift @files;
                print "Original: $not_deleted\n";
                for my $file (@files) {
                    if ( unlink $file->name ) {
                        print "Gelöscht: $file\n";
                        $total_size += $file->size;
                    }
                }
            }
            # Ask
            elsif ($ask) {
                my $inp;
                my @inpa;
                print "MD5: $md5\n";
                print
"Welche Datei möchten sie Behallten? Bitte geben sie die nummer(n) an, getrennt durch ',' oder '0' um alle zu behalten.\n";
                for ( my $i = 1 ; $i <= @files ; $i++ ) {
                    print "$i: $files[$i-1]\n";
                }
                $inp = <STDIN>;
                @inpa = split( /,/, $inp );
                while ( grep( /[^\d|\s]/, @inpa ) ) { # verify inputted characters
                    print "Next try! Please enter only numbers, ',' and whitespaces!\n";
                    $inp = <STDIN>;
                    @inpa = split( /,/, $inp );
                }
                @inpa = sort @inpa;
                if ( $inpa[0] == 0 ) {                # delete nothing, if '0' was entered
                    print "Nichts gelöscht.\n";
                }
                else {                                # delete!
                    print "Lösche diese Datei:\n";
                    my $status;
                    for ( my $i = 0 ; $i < @files ; $i++ ) {
                        $status = 0;
                        for my $j (@inpa) {
                            $status = 1 if $j - 1 == $i;
                        }
                        if ( $status == 0 ) {
                            print "Gelöscht: ", $i + 1, ": ", $files[$i], "\n" if ( unlink $files[$i]->name );
                        }
                    }
                }
            } ## end elsif ($ask)
             # Show
            else {
                print "MD5: $md5\n";
                for my $file (@files) {
                    print "$file\n";
                }
            }

            print "\n";
        } ## end for my $md5 ( keys %md5)
    } ## end MD5_64KB: for my $files_aref ( values...)
} ## end FILE_SIZE: for my $files_aref ( values...)

$total_size = $total_size / 1024 / 1024;
if ($delete) {
    print "$total_size MiB more free.\n";
}

__END__

=head1 NAME

find_duplicates - Find Duplicates in Directorys

=head1 SYNOPSIS

find_duplicates [-d|-a] [DIRECTORY]...

=head1 DESCRIPTION

find_duplicates searches and print/delete files recursivly in
the given directories. If no directorie is given then the
currently working directory is used.

If Option -d is not explicity defined, then the duplicated files
will only be shown. If it is defined, then all expect one file
will be deleted.

If Option -a is given, you will be asked, which
file will be kept. Choose the number of the file you want to keep
or '0' to keep all files. You can enter more than one number,
separated by ',', to keep several files.

=head1 OPTIONS

=over

=item B<-d>, B<--delete>

Delete: Files will be Deleted.

=item B<-a>, B<--ask>

Ask: Ask, which file should be kept

=item B<-h>, B<--help>

Help: Print this Help

=item B<-m>, B<--man>

Manpage: Shows a manpage.

=back

=head1 AUTHOR

David Raab

=head1 LICENSE

MIT LicenseCopyright (c) 2008-2009 David Raab<david.raab@q-dsl.de>

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
